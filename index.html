<!DOCTYPE html>
<meta charset="utf-8">
<style>

.node circle {
  fill: #999;
}

.node text {
  font: 10px sans-serif;
}

.node--internal circle {
  fill: #555;
}

.node--internal text {
  text-shadow: 0 1px 0 #fff, 0 -1px 0 #fff, 1px 0 0 #fff, -1px 0 0 #fff;
}

.link {
  fill: none;
  stroke: #555;
  stroke-opacity: 0.4;
  stroke-width: 1.5px;
}

</style>
<input id="modeInput1" type="radio" name="mode" value="linear" checked>
<label for=modeInput1">Linear</label>
<input id="modeInput2" type="radio" name="mode" value="radial">
<label for=modeInput2">Radial</label>
<input id="fileInput" type="file" name="input-name" />
<button id="save">Save SVG</button>
<svg width="1400" height="1920"></svg>
<script src="./FileSaver.js.min"></script>
<script src="./d3.js"></script>
<script>

let svg = d3.select("svg");
let height = svg.attr("height");
let width = svg.attr("width");
let fileInput = document.getElementById('fileInput');

fileInput.addEventListener('input', function(event) {
  d3.json(event.currentTarget.files[0].name, function(e, d) {
    svg.select('g').remove();
    if (document.getElementById('modeInput1').checked) {
      linearPlot(svg, d);
    } else {
      radialPlot(svg, d);
    }
  })
});

function linearPlot(svg, data) {

  let g = svg.append("g")
    .attr("transform", "translate(" + 0 + "," + 20 + ")"); // TODO: Translate for margin.
  let imported = d3.hierarchy(data);
  let tree = d3.tree()
    .size([height - 40, width - 80])

  let root = tree(imported);

  let link = g.selectAll('.link')
    .data(root.descendants().slice(1))
    .enter()
    .append("path")
    .attr("class", "link")
    .attr("d", function(d) {
      return "M" + d.y + "," + d.x
        + "C" + (d.y + d.parent.y) / 2 + "," + d.x
        + " " + (d.y + d.parent.y) / 2 + "," + d.parent.x
        + " " + d.parent.y + "," + d.parent.x;
    })

  let node = g.selectAll('.node')
    .data(imported.descendants())
    .enter()
    .append("g")
    .attr("class", function(d) { return "node" + (d.children ? " node--internal" : " node--leaf"); })
    .attr("transform", function(d) { return "translate(" + d.y + "," + d.x + ")"; });

  node.append("circle")
    .attr("r", 2.5);

  node.append("text")
    .attr("dy", "0.31em")
    .attr("x", 6)
    .attr("text-anchor", "center")
    .text(function(d) { return d.data.name; });
}

// TODO: Export to vector SVG.
function radialPlot(svg, data) {
  let g = svg.append("g")
    .attr("transform", "translate(" + (width / 2) + "," + (height / 2) + ")");

  let imported = d3.hierarchy(data);
  // TODO: Radial SVG's should be squares.
  let tree = d3.tree()
    .size([2 * Math.PI, width / 2])
    .separation(function(a, b) { return (a.parent == b.parent ? 1 : 2) / a.depth });
  let root = tree(imported);

  let link = g.selectAll(".link")
    .data(root.links())
    .enter()
    .append("path")
    .attr("class", "link")
    .attr("d", d3.linkRadial()
    .angle(function(d) { return d.x; })
    .radius(function(d) { return d.y; }));

  let node = g.selectAll(".node")
    .data(imported.descendants())
    .enter()
    .append("g")
    .attr("class", function(d) { return "node" + (d.children ? " node--internal" : " node--leaf"); })
    .attr("transform", function(d) { return "translate(" + radialPoint(d.x, d.y) + ")" });

  node.append("circle")
    // TODO: Confirm this works.
    .style("fill", function(d) { return d.color })
    .attr("r", function(d) { return 5 - (d.depth / 2); });

  node.append("text")
    .style("font-size", function(d) { return (20 - d.depth * 2) + "px"; })
    .attr("dy", "0.31em")
    .attr("x", function(d) { return d.x < Math.PI === !d.children ? 6 : -6; })
    .attr("text-anchor", "middle")
    .attr("transform", function(d) { return "rotate(" + (d.x < Math.PI ? d.x - Math.PI / 2 : d.x + Math.PI / 2) * 180 / Math.PI + ")translate(0,-" + (20 - (d.depth * 3)) + ")"; })
    .text(function(d) { return d.data.name; });
}

d3.select("#save")
  .on("click", writeDownloadLink);

function writeDownloadLink() {
  let html = d3.select("svg")
    .attr("version", 1.1)
    .attr("xmlns", "http://www.w3.org/2000/svg")
    .node().outerHTML;

  let blob = new Blob([html], { type: "image/svg+xml" });
  saveAs(blob, "output.svg");
};

function radialPoint(x, y) {
  return [(y = +y) * Math.cos(x -= Math.PI / 2), y * Math.sin(x)];
}

  </script>
</body>
